---
title: 微信小程序
date: 2018-04-10 19:00:18
tags: [微信小程序,Vue,React,es3,es5,es6,es7,javascript,函数编程]
---

> 写在前面的话
> 本文只是对于官网文档的总结和个人使用经验结合的教程，如果和你的编程风格有出入请出门左转。由于之前使用过Vue和react,而微信小程序和Vue还有react也有相似之处，所以我会在阐述的过程中和两个框架进行比较(如果有阐述不对的地方请指出)。

> 主要参考[微信小程序官方文档](https://developers.weixin.qq.com/miniprogram/dev/index.html/ "微信小程序") 

### 正文开始

#### 准备工作
* 1.开发者账号，如果没有开发者账号可以选择体验版本，虽然不影响开发，但是不能实时在真机上调试。申请地址[传送门]( https://mp.weixin.qq.com/wxopen/waregister?action=step1 / "申请开发者账号") ;
* 2.一台电脑？(大概这是标配)
* 3.es3、5、6、7知识。这里你可以随便使用es6(开发工具自带es6转es5,如果你使用像wepy和mpvue这样的框架进行开发的话,框架自身带有babel当然也是随便用啦)
* 4.html、css知识(虽然在原生小程序开发中使用的是小程序提供的组件进行开发的，但是其实和本来的div+css开发大相径庭)
* 5.开发者工具,这里推荐使用微信官方的ide(因为可以实时预览而且还可以在手机上预览),如果你使用的是mpvue或者是wepy的话可以使用市面上比较流行的编辑器配合微信开发工具一起进行开发，比如webstorm、phpstorm、vscode、atom等等(但要注意有些编辑器里面并不提供小程序语法的ide,所以你可能在调用小程序提供的一些api的时候需要全程手打)。各类编辑器传送门([微信开发工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html "微信开发工具")、[webstorm](https://www.jetbrains.com/webstorm/ "webstorm")、[phpstorm](https://www.jetbrains.com/phpstorm/ "phpstorm")、[vscode](https://code.visualstudio.com/ "vscode")、[atom](https://atom.io/ "atom"))。

#### 简述小程序
> 微信小程序，故名思议是依附在微信上的小程序，这也是微信小程序当时一夜爆红的原因，因为微信小程序无须用户主动安装，只要安装微信，通过二维码或是搜索小程序名即可进行使用，这也是'即用即开的速食思想'。个人认为其实就是微信用了一个用户量进行了一个诱饵让开发者主动性的为微信增加功能，这其实和facebook当时的做法很像，当时facebook允许开发者在facebook里开发小游戏，一方面开发者坐拥了facebook的用户，而facebook拥有了开发者开发的程序丰富了facebook的功能。现在微信也是这样的一个做法，一方面开发着可以坐拥微信这样的一个流量池，而微信则可以以这个作为诱饵使开发者来开发小程序丰富微信，现在也越来越多的公司前期为了节约成本而先在微信上推出小程序，当用户稳定的时候再开发自己的APP，其实这样也无形中在推销微信，因为如果想使用这个只有小程序的产品，那样不得不的是需要下载微信，这样一个互利的过程其实对双方都是好的。

#### 小程序的简单工作原理
微信小程序在用户首次打开的时候从微信的服务器上加载该小程序的完整程序包到用户本地，紧接着通过 app.json 的 pages 字段就可以知道当前小程序的所有页面路径，根据配置微信客户端就把首页的代码装载进来，通过小程序底层的一些机制(生命周期在后面会提到)，就可以渲染出这个首页。

#### 小程序开发目录结构(罗列的均为初始项目结构)
1.原生小程序开发目录结构
```
├── _pages  存放所有页面
|   ├── _index  每个文件夹对应四个文件(.wxml、.wxss、.js、.json，且文件名必须和文件夹名字相同)
|   |   ├── index.wxml
|   |   ├── index.wxss
|   |   ├── index.js
|   |   └── index.json
|   └── _logs
|       ├── logs.wxml
|       ├── logs.wxss
|       ├── logs.js
|       └── logs.json
├── _utils
|   └── util.js  定义公共方法并导出
├── app.js    小程序声明周期函数以及一些公共变量和方法存放地方
├── app.json  对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等
├── app.wxss  全局公用样式
└── project.config.json  开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。
```

2.mpvue开发目录结构
```
|-- build                            // 项目构建(webpack)相关代码
|   |-- build.js                     // 生产环境构建代码
|   |-- check-version.js             // 检查node、npm等版本
|   |-- dev-client.js                // 热重载相关
|   |-- dev-server.js                // 构建本地服务器
|   |-- utils.js                     // 构建工具相关
|   |-- webpack.base.conf.js         // webpack基础配置
|   |-- webpack.dev.conf.js          // webpack开发环境配置
|   |-- webpack.prod.conf.js         // webpack生产环境配置
|   |-- vue-loader.conf.js           // vue-loader配置
|-- config                           // 项目开发环境配置
|   |-- dev.env.js                   // 开发环境变量
|   |-- index.js                     // 项目一些配置变量
|   |-- prod.env.js                  // 生产环境变量
|   |-- test.env.js                  // 测试环境变量
|-- src                              // 源码目录
|   |-- components                     // vue公共组件
|   |-- pages                          // 存放页面
|       |-- counter 
|           |-- index.vue               // 页面文件
|           |-- main.js                 // 页面生命周期、自定义事件方法
|           |-- store.js                // vuex状态管理
|       |-- index 
|           |-- index.vue 
|           |-- main.js
|       |-- logs  
|           |-- index.vue  
|           |-- main.js    
|   |-- App.vue                        // 页面入口文件
|   |-- main.js                        // 程序入口文件，加载各种公共组件
|-- static                           // 静态文件，比如一些图片，json数据等
|-- dist                             // 编译后的文件，在微信开发工具中打开预览，结构和原生开发一致
|-- .babelrc                         // ES6语法编译配置
|-- .editorconfig                    // 定义代码格式
|-- .gitignore                       // git上传需要忽略的文件格式
|-- README.md                        // 项目说明
|-- favicon.ico
|-- .postcssrc.js                    // postcss配置入口
|-- index.html                       // 入口页面
|-- package.json                     // 项目基本信息
└-- project.config.json              //开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。
```

#### 生命周期
> 这里要主要，微信小程序的生命周期分两个，一个是小程序的生命周期，一个为页面的生命周期，开发中要仔细分辨清楚和判断需要使用哪些生命周期。 

1.小程序的生命周期

| 属性        | 类型    |  描述  |  触发时机  |
| :----:   | :--:   | :-----: | :------: |
| onLaunch        | Function      |   生命周期函数--监听小程序初始化    |  当小程序初始化完成时，会触发 onLaunch（全局只触发一次）    |
| onShow        | Function      |   生命周期函数--监听小程序显示    |   当小程序启动，或从后台进入前台显示，会触发 onShow    |
| onHide        | Function      |   生命周期函数--监听小程序隐藏    |   当小程序从前台进入后台，会触发 onHide    |
| onError        | Function      |   错误监听函数    |   当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息    |
| onPageNotFound        | Function     |   页面不存在监听函数    |  当小程序出现要打开的页面不存在的情况，会带上页面信息回调该函数，详见下文    |
| 其他        | Any      |       |   开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访    |

```javascript
实例代码
App({
  onLaunch: function(options) {
    // Do something initial when launch.
  },
  onShow: function(options) {
      // Do something when show.
  },
  onHide: function() {
      // Do something when hide.
  },
  onError: function(msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
```

> tip:
> 1. 前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。
> 2. onLaunch和onShow都可以携带指定参数，具体看下表

| 字段        | 类型    |  说明  |
| :----:   | :--:   | :-----: |
| path       | String      |   打开小程序的路径    |
| query        | Object      |   打开小程序的query    |
| scene        | Number      |   打开小程序的场景值   |
| shareTicket  | String      |   shareTicket转发信息    |
| referrerInfo | Object      |   当场景为由从另一个小程序或公众号或App打开时，返回此字段    |
| referrerInfo.appId | String    |   来源小程序或公众号或App的 appId    |
| referrerInfo.extraData   | Object    |  来源小程序传过来的数据，scene=1037或1038时支持   |

> 关于生命周期需要说一丢丢的关注点:
> 1.小程序的生命周期
> onLaunch 小程序生命周期函数,且在小程序初始化时执行,有且只执行一次。
> onShow 小程序生命周期函数,小程序从后台进入前台的时候会触发,这里需要注意一个触发顺序:先触发页面的`onShow`生命钩子再触发小程序的`onShow`生命周期钩子,所以在使用`onShow`的时候逻辑需要注意，而且从第三方跳转(场景主要是APP唤醒、小程序唤醒、公众号唤醒)唤醒时参数须从小程序的`onShow`生命周期中的params中获取，因为在初始化的过程中也会触发小程序的`onShow`，且`onShow`是可以多次触发的，这样可以保证每次唤醒的参数都是我们可取的。所以不应该在小程序`onLaunch`中获取回传参数。
> 2.页面的生命周期
> onLoad  有且只在页面初始化时执行一次，若页面进入页面栈再次呼出则不会触发`onLoad`，只会触发`onShow`。若在跳转时附加参数，只可以在`onLoad`中获取，获取方式为`options.query`
> onShow  当页面初始化时执行一次，从页面栈中被呼出时(即位于栈顶)也会执行，所以如果想要在页面中执行每次展示更新数据之类的操作的话，建议在`onShow`中执行。
> onHide  注意当页面非页面栈顶的同时会触发`onHide`

#### data
> 小程序页面的`data`和`Vue`的`data`实现机制不太相同。
* 小程序的data:初始化数据将作为页面的第一次渲染。`data` 将会以 `JSON` 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 `JSON` 的格式：字符串，数字，布尔值，对象，数组。
* Vue 将遍历此对象所有的属性，并使用 `Object.defineProperty` 把这些属性全部转为 `getter/setter`。
> 使用上的区别
```javascript
1. 小程序

Page({
  data:{
    msg:'aaa'
  },
  changeData(){
    this.setData({msg:'bbb'});  // 我们需要关注的是this.setData和react中的写法非常像，而且也是异步的。
  }
});

2. Vue

new Vue{
  el:'#app',
  data:{msg:'aaa'},
  methods:{
    changeData(){this.msg='bbb'}
  }
};

or 

<script>
export default {
  name:'temp',
  data(){
    return {
      msg:'aaa'
    }
  },
  methods:{
    changeData(){this.msg='bbb'}
  }
}
</script>
```

#### 组件、api(这里不做详解，只在下面有需要的地方会对特定api讲解)
> 简单的概括一下: 微信给我们提供的组件有些像React-native的组件一样，更符合他的运行环境，而且组件中提供了很多便捷的属性和方法供我们使用;而api则是微信比较吸引开发者的地方，因为开发者可以通过微信提供的api调用微信所支持的一些能力，比如: 获取微信个人信息、绑定手机号、摄像头、罗盘等等。。。。。
> 传送门[组件](https://developers.weixin.qq.com/miniprogram/dev/component/ "组件")、[api](https://developers.weixin.qq.com/miniprogram/dev/api/ "api")

#### 路由
> 在小程序中所有页面的路由全部由框架进行管理。框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：

| 路由方式        | 页面栈表现 |
| :----:   | :--:   |
| 初始化       | 新页面入栈     |
| 打开新页面        | 新页面入栈      |
| 页面重定向        | 当前页面出栈，新页面入栈     |
| 页面返回  | 页面不断出栈，直到目标返回页，新页面入栈      |
| Tab 切换 | 页面全部出栈，只留下新的 Tab 页面     |
| 重加载 | 页面全部出栈，只留下新的页面   |

> 路由方式，对于路由的触发方式以及页面生命周期函数如下：

| 路由方式        | 触发时机    |  路由前页面  |  路由后页面  |
| :----:   | :--:   | :-----: | :------: |
| 初始化       | 小程序打开的第一个页面     |       |  onLoad, onShow    |
| 打开新页面        | 调用 `API wx.navigateTo` 或使用组件 `<navigator open-type="navigateTo"/>`     |   onHide    |   onLoad, onShow    |
| 页面重定向       | 调用 `API wx.redirectTo` 或使用组件 `<navigator open-type="redirectTo"/>`     |   onUnload    |   onLoad, onShow    |
| 页面返回        | 调用 `API wx.navigateBack` 或使用组件`<navigator open-type="navigateBack">`或用户按左上角返回按钮      |   onUnload    |   onShow    |
| Tab 切换        | 调用 `API wx.switchTab` 或使用组件 `<navigator open-type="switchTab"/>` 或用户切换 Tab     |       |      |
| 重启动        | 调用 `API wx.reLaunch` 或使用组件 `<navigator open-type="reLaunch"/>`     |   onUnload    |   onLoad, onShow    |

> 关于路由需要注意的几点
* `navigateTo`, `redirectTo` 只能打开非 tabBar 页面,若要打开tabbar页面需要使用`switchTab`。
* `switchTab` 只能打开 tabBar 页面。
* `reLaunch` 可以打开任意页面。
* 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
* 调用页面路由带的参数可以在目标页面的`onLoad`中获取。
* 页面栈最多可以承载五个页面，建议多使用`redirectTo`打开页面。

#### 数据绑定
> 小程序和Vue都是采用 `Mustache` 语法，将变量用双花括号包裹起来
```html
1. 小程序
<view src="item-{{msg}}"  id="{{ true ? msg : '' }}">{{msg}}</view>

2. Vue
<div :msg="msg" :_msg=" true ? msg : '' ">{{msg}}</div>
但在Vue中不推荐写过多的逻辑在{{}}中，这样对于后期维护是不利的，建议写在computed(即计算属性)中。
```

#### 指令(由于微信小程序提供的一些便捷的api和Vue提供的指令极为相似，所以这里我统称为指令)
* v-for and wx:for
```html
<block>
  // 不指定下标名和变量名是，默认下标为index，变量为item
  <view wx:for="{{array}}" wx:key="index">{{index}}---{{item}}</view>
  // 也可指定变量和下标
  <view wx:for="{{array}}" wx:for-item="ite" wx:for-index="idx"  wx:key="idx">{{idx}}---{{ite}}</view>
</block>

// 建议每次进行列表渲染的时候都写上wx:key,当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

Page({
  data:{
    array:['1','2','3']
  }
})

<template>
  <ul>
    <li v-for="(item,index) in array" :key="index">{{item}}</li>
  </ul>
</template>
<script>
  export default {
    data(){return {array:[1,2,3]}},
  },
</script>
```

* wx:if hidden

#### 未完待续
